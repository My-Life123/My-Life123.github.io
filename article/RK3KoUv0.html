<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        Zookeeper分布式协调中间件使用 - undefined
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> sometimes code， sometimes design </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar radius">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>FENG.M</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>HOME</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>TAGS</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>ARCHIVES</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>ABOUT</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>SEARCH</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">一、Zookeeper分布式协调中间件快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFzookeeper"><span class="toc-text">1. 什么是zookeeper</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B6%89%E5%8F%8A%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">2. 涉及的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Zookeeper%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">3. Zookeeper核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-text">数据模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-text">4. 节点类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6"><span class="toc-text">5. 事件监听机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E6%93%8D"><span class="toc-text">6. Zookeeper客户端实操</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8"><span class="toc-text">7. Zookeeper客户端使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="toc-text">8. 事务日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E6%95%B0%E6%8D%AE%E5%BF%AB%E7%85%A7"><span class="toc-text">9. 数据快照</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%9B%86%E7%BE%A4%E7%89%B9%E6%80%A7"><span class="toc-text">二、Zookeeper客户端使用与集群特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Zookeeper-ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-text">1. Zookeeper ACL权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E6%A8%A1%E5%BC%8F-Scheme"><span class="toc-text">权限模式(Scheme)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E5%AF%B9%E8%B1%A1-ID"><span class="toc-text">授权对象(ID)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E4%BF%A1%E6%81%AF-Permission"><span class="toc-text">权限信息(Permission)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4"><span class="toc-text">权限控制命令:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%88%E6%9D%83Id%E7%94%9F%E6%88%90"><span class="toc-text">授权Id生成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IP%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F"><span class="toc-text">IP授权模式:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Super-%E8%B6%85%E7%BA%A7%E7%AE%A1%E7%90%86%E5%91%98%E6%A8%A1%E5%BC%8F"><span class="toc-text">Super 超级管理员模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Zookeeper-Java%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">2. Zookeeper Java客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA"><span class="toc-text">项目构建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ZooKeeper-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-text">ZooKeeper 构造函数核心参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Apache-Curator-%E5%BC%80%E6%BA%90%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">3. Apache Curator 开源客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Curator"><span class="toc-text">什么是 Curator</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Curator-%E5%AE%9E%E6%88%98"><span class="toc-text">Curator 实战</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E5%88%9B%E5%BB%BA"><span class="toc-text">会话创建</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Zookeeper%E9%9B%86%E7%BE%A4%E7%89%B9%E6%80%A7"><span class="toc-text">4. Zookeeper集群特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ZooKeeper-%E9%9B%86%E7%BE%A4%E2%BB%86%E8%89%B2"><span class="toc-text">ZooKeeper 集群⻆色</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Zookeeper-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E5%AE%89%E8%A3%85"><span class="toc-text">Zookeeper 集群模式安装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ZooKeeper-%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9-%E7%BC%A9%E5%AE%B9"><span class="toc-text">ZooKeeper 动态扩容&#x2F;缩容</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">search</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> sometimes code， sometimes design </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Zookeeper分布式协调中间件使用
    </div>

    <div class="post-meta">
        <span class="attr">Post：<span>2021-06-19 15:37:00</span></span>
        
        <span class="attr">Tags：/
        
        <a class="tag" href="/tags/#ZK" title="ZK">ZK</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">Visit：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h4>目录</h4>

<ul>
<li><a href="#%E4%B8%80%E3%80%81">Zookeeper分布式协调中间件快速入门</a><ul>
<li><a href="#1.1">1. 什么是zookeeper</a></li>
<li><a href="#1.2">2. 涉及的应用</a></li>
<li><a href="#1.3">3. Zookeeper核心概念</a></li>
<li><a href="#1.4">4. 节点类型</a></li>
<li><a href="#1.5">5. 事件监听机制</a></li>
<li><a href="#1.6">6. Zookeeper 客户端实操</a></li>
<li><a href="#1.7">7. Zookeeper 客户端使用</a></li>
<li><a href="#1.8">8. 事务日志</a></li>
</ul>
<ul>
<li><a href="#1.9">9. 数据快照</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E3%80%81">Zookeeper客户端使用与集群特性</a><ul>
<li><a href="#2.1">1. Zookeeper ACL权限控制</a></li>
<li><a href="#2.2">2. Zookeeper Java客户端</a></li>
<li><a href="#2.3">3. Apache Curator 开源客户端</a></li>
<li><a href="#2.4">4. Zookeeper集群特性</a></li>
</ul>
</li>
</ul>
<h3 id="一、Zookeeper分布式协调中间件快速入门"><a href="#一、Zookeeper分布式协调中间件快速入门" class="headerlink" title="一、Zookeeper分布式协调中间件快速入门"></a><span id = "一、">一、Zookeeper分布式协调中间件快速入门</span></h3><h4 id="1-什么是zookeeper"><a href="#1-什么是zookeeper" class="headerlink" title="1. 什么是zookeeper"></a><span id = "1.1">1. 什么是zookeeper</span></h4><p>   通过官网介绍：“ZooKeeper是一种集中式服务，可维护配置信息，命名，提供分布式同步和提供组服务。”</p>
<h4 id="2-涉及的应用"><a href="#2-涉及的应用" class="headerlink" title="2. 涉及的应用"></a><span id = "1.2">2. 涉及的应用</span></h4><ol>
<li>Apache Dubbo</li>
<li>Apache Kafka</li>
<li>Spring Cloud Zookeeper</li>
<li>Neo4j</li>
<li>Apache Hbase</li>
<li>Apache Hive</li>
<li>Apache Spark</li>
<li>Apache Flume</li>
<li>Apache Solr</li>
<li>Apache Hadoop</li>
<li>Apache Hadoop Reduce</li>
<li>京东，淘宝，阿里，美团自研中间件</li>
</ol>
<h4 id="3-Zookeeper核心概念"><a href="#3-Zookeeper核心概念" class="headerlink" title="3. Zookeeper核心概念"></a><span id = "1.3">3. Zookeeper核心概念</span></h4><h5 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h5><p><img src="https://my-life.gitee.io/mkphotorepository/202106/001.jpeg" alt="alt "></p>
<p>Zookeeper维护一个类似文件系统的数据模型<br>每个子目录项都被称作为 node(目录节点)，和文件系统类似，我们能够自由的增加、删除 node，在一个node下增加、删除子znode。<br>有6 种类型的znode:(3.5.x版本以前只有前面四种)</p>
<h5 id="4-节点类型"><a href="#4-节点类型" class="headerlink" title="4. 节点类型"></a><span id = "1.4">4. 节点类型</span></h5><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PERSISTENT</td>
<td align="left">持久节点</td>
</tr>
<tr>
<td align="left">PERSISTENT_SEQUENTIAL</td>
<td align="left">持久序号节点</td>
</tr>
<tr>
<td align="left">EPHEMERAL</td>
<td align="left">临时节点(不可在拥有子节点)</td>
</tr>
<tr>
<td align="left">EPHEMERAL_SEQUENTIAL</td>
<td align="left">临时序号节点(不可在拥有子节点)</td>
</tr>
<tr>
<td align="left">Container</td>
<td align="left">3.5.3 版本新增,当前节点下没有子节点此节点会被zk清除 默认60s检查一次</td>
</tr>
<tr>
<td align="left">TTL</td>
<td align="left">3.5.3 版本新增，默认禁用，只能通过系统配置 zookeeper.extendedTypesEnabled=true 开启，不稳定</td>
</tr>
</tbody></table>
<h4 id="5-事件监听机制"><a href="#5-事件监听机制" class="headerlink" title="5. 事件监听机制"></a><span id = "1.5">5. 事件监听机制</span></h4><p>客户端注册监听它关心的任意节点，或者目录节点及递归子目录节点</p>
<ol>
<li>如果注册的是对某个节点的监听，则当这个节点被删除，或者被修改时，对应的客户端将被 通知</li>
<li>如果注册的是对某个目录的监听，则当这个目录有子节点被创建，或者有子节点被删除，对 应的客户端将被通知</li>
<li>如果注册的是对某个目录的递归子节点进行监听，则当这个目录下面的任意子节点有目录结 构的变化(有子节点被创建，或被删除)或者根节点有数据变化时，对应的客户端将被通知。</li>
</ol>
<p><font color='red'>注意:所有的通知都是一次性的，及无论是对节点还是对目录进行的监听，一旦触发，对应的监听即被移除。递归子节点，监听是对所有子节点的，所以，每个子节点下面的事件同样只会被触 发一次。</font></p>
<p>下面安装zk服务，安装步骤参考这篇博客<a href="https://blog.cnsyear.cn/article/1zbuiK74.html">安装zk3.4.9服务</a>。这里实际操作使用3.5.9版本.</p>
<h4 id="6-Zookeeper客户端实操"><a href="#6-Zookeeper客户端实操" class="headerlink" title="6. Zookeeper客户端实操"></a><span id = "1.6">6. Zookeeper客户端实操</span></h4><p>进入zk客户端</p>
<blockquote>
<p>bin/zkCli.sh -server 127.0.0.1 #server后面代表连接指定地址</p>
</blockquote>
<p>输入命令 help 查看zookeeper所支持的所有命令 <br/><br>创建zookeeper 节点命令<br/><br>create [-s] [-e] [-c] [-t ttl] path [data] [acl]<br/><br>中括号为可选项，没有则默认创建持久化节点 -s: 顺序节点<br/><br>-e: 临时节点<br/><br>-c: 容器节点<br/><br>-t: 可以给节点添加过期时间，默认禁用，需要通过系统参数启用 (-Dzookeeper.extendedTypesEnabled=true, znode.container.checkIntervalMs : (Java system property only) New in 3.5.1: The time interval in milliseconds for each check of candidate container and ttl nodes. Default is “60000”.)<br/><br>创建节点:<br/><br>create /node-test some-data 如上，没有加任何可选参数，创建的就是持久化节点<br><img src="https://my-life.gitee.io/mkphotorepository/202106/002.png" alt="alt "><br>查看节点数据: get /node-test<br><img src="https://my-life.gitee.io/mkphotorepository/202106/003.png" alt="alt "><br>修改节点数据<br>set /node-test second-modify<br><img src="https://my-life.gitee.io/mkphotorepository/202106/004.png" alt="alt "></p>
<p>查看节点状态信息 stat /node-test<br><img src="https://my-life.gitee.io/mkphotorepository/202106/005.jpg" alt="alt "></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Stat: 字段含义</span><br><span class="line"></span><br><span class="line">cZxid:创建znode的事务ID(Zxid的值)。</span><br><span class="line">mZxid:最后修改znode的事务ID。 pZxid:最后添加或删除子节点的事务ID(子节点列表发生变化才会发生改变)。</span><br><span class="line">ctime:znode创建时间。</span><br><span class="line">mtime:znode最近修改时间。</span><br><span class="line">dataVersion:znode的当前数据版本。 </span><br><span class="line">cversion:znode的子节点结果集版本(一个节点的子节点增加、删除都会影响这个版本)。 </span><br><span class="line">aclVersion:表示对此znode的acl版本。 </span><br><span class="line">ephemeralOwner:znode是临时znode时，表示znode所有者的session ID。 如果znode不是 临时znode，则该字段设置为零。</span><br><span class="line">dataLength:znode数据字段的⻓度。</span><br><span class="line">numChildren:znode的子znode的数量。</span><br></pre></td></tr></table></figure>
<p>根据状态数据中的版本号有并发修改数据实现乐观锁的功能 比如: 客户端首先获取版本信息，get -s /node-test<br><img src="https://my-life.gitee.io/mkphotorepository/202106/006.png" alt="alt "><br>/node-test 当前的数据版本是 1 ， 这时客户端 用 set 命令修改数据的时候可以把版本号带上<br><img src="https://my-life.gitee.io/mkphotorepository/202106/007.png" alt="alt "><br>如果在执行上面 set命令前， 有人修改了数据，zookeeper 会递增版本号， 这个时候，如果再 用以前的版本号去修改，将会导致修改失败，报如下错误<br><img src="https://my-life.gitee.io/mkphotorepository/202106/008.png" alt="alt "><br>创建子节点， 这里要注意，zookeeper是以节点组织数据的，没有相对路径这么一说，所以， 所有的节点一定是以 / 开头。</br><br>create /node-test/test-sub-node<br><img src="https://my-life.gitee.io/mkphotorepository/202106/009.png" alt="alt "></p>
<p>查看子节点信息，比如根节点下面的所有子节点， 加一个大写 R 可以查看递归子节点列表 ls / 创建临时节点<br>create -e /ephemeral data</br><br>create 后跟一个 -e 创建临时节点 ， 临时节点不能创建子节点<br><img src="https://my-life.gitee.io/mkphotorepository/202106/010.png" alt="alt "><br>创建序号节点，加参数 -s</br><br>create /seq-parent data // 创建父目录，单纯为了分类，非必须 create -s /seq-parent/ data // 创建顺序节点。顺序节点将再seq-parent 目录下面，顺序递增</br><br>为了容纳子节点，先创建个父目录 /seq-parent<br><img src="https://my-life.gitee.io/mkphotorepository/202106/011.png" alt="alt "><br>也可以再序号节点前面带一个前缀<br><img src="https://my-life.gitee.io/mkphotorepository/202106/010.png" alt="alt "><br>创建临时顺序节点,其它增删查改和其他节点无异， create -s -e /ephemeral-node</br><br><font color='red'>注意：临时节点由于不能创建子节，点所以创建顺序节点无前缀</font><br>创建容器节点</br><br>create -c /container 容器节点主要用来容纳字节点，如果没有给其创建子节点，容器节点表现和持久化节点一样，如 果给容器节点创建了子节点，后续又把子节点清空，容器节点也会被zookeeper删除。</p>
<p>事件监听</br><br>针对节点的监听:一定事件触发，对应的注册立刻被移除，所以事件监听是一次性的</br><br>get -w /path   // 注册监听的同时获取数据</br><br>stat -w /path // 对节点进行监听，且获取元数据信息</br><br><img src="https://my-life.gitee.io/mkphotorepository/202106/013.png" alt="alt "><br>针对目录的监听，如下图，目录的变化，会触发事件，且一旦触发，对应的监听也会被移除，后 续对节点的创建没有触发监听事件<br>ls -w /path<br><img src="https://my-life.gitee.io/mkphotorepository/202106/014.png" alt="alt "><br>针对递归子目录的监听</br><br>ls -R -w /path : -R 区分大小写，一定用大写</br><br>如下对/test 节点进行递归监听，但是每个目录下的目录监听也是一次性的，如第一次在/test</br> 目录下创建节点时，触发监听事件，第二次则没有，同样，因为时递归的目录监听，所以</br> 在/test/sub0下进行节点创建时，触发事件，但是再次创建/test/sub0/subsub1节点时，没有 触发事件。</br><br>Zookeeper事件类型一览:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">None: 连接建立事件</span><br><span class="line">NodeCreated: 节点创建</span><br><span class="line">NodeDeleted: 节点删除</span><br><span class="line">NodeDataChanged:节点数据变化 </span><br><span class="line">NodeChildrenChanged:子节点列表变化 </span><br><span class="line">DataWatchRemoved:节点监听被移除 </span><br><span class="line">ChildWatchRemoved:子节点监听被移除</span><br></pre></td></tr></table></figure>
<h4 id="7-Zookeeper客户端使用"><a href="#7-Zookeeper客户端使用" class="headerlink" title="7. Zookeeper客户端使用"></a><span id = "1.7">7. Zookeeper客户端使用</span></h4><p>由于zookeeper客户端和服务端源码是绑定在一起的，因为之前在实际项目使用过程中遇到过坑，建议使用和服务端代码相同版本的客户端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入 maven --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>init 方法被执行后，就可以用zookeeper实例进行通过调用api操作,主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper zooKeeper=null;</span><br><span class="line">public void initailZkServer() throws IOException, InterruptedException &#123;</span><br><span class="line">    final CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line">    zooKeeper = new ZooKeeper(&quot;127.0.0.1:2181&quot;, 5000, event -&gt; &#123;</span><br><span class="line">        if (event.getState() == Watcher.Event.KeeperState.SyncConnected &amp;&amp; event.getType() == Watcher.Event.EventType.None) &#123;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            System.out.println(&quot;连接成功！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(&quot;连接中...&quot;);</span><br><span class="line">    countDownLatch.await();</span><br></pre></td></tr></table></figure>
<h4 id="8-事务日志"><a href="#8-事务日志" class="headerlink" title="8. 事务日志"></a><span id = "1.8">8. 事务日志</span></h4><p>针对每一次客户端的事务操作，Zookeeper都会将他们记录到事务日志中，当然，Zookeeper也 会将数据变更应用到内存数据库中。我们可以在zookeeper的主配置文件zoo.cfg 中配置内存中 的数据持久化目录，也就是事务日志的存储路径 dataLogDir. 如果没有配置dataLogDir(非必 填), 事务日志将存储到dataDir (必填项)目录。</p>
<p>zookeeper提供了格式化工具可以进行数据查看事务日志数据 org.apache.zookeeper.server.LogFormatter</p>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -cp :/Users/m_yf/soft/zookeeper-3.5.9/lib/slf4j-api-1.7.25.jar:/Users/m_yf/soft/zookeeper-3.5.9/lib/zookeeper-3.5.9.jar:/Users/m_yf/soft/zookeeper-3.5.9/lib/zookeeper-jute-3.5.9.jar org.apache.zookeeper.server.LogFormatter /Users/m_yf/soft/zookeeper-3.5.9/logs/version-2/log.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成结果如下：<br><img src="https://my-life.gitee.io/mkphotorepository/202106/015.png" alt="alt "></p>
<p>从左到右分别记录了操作时间，客户端会话ID，CXID,ZXID,操作类型，节点路径，节点数据(用 #+ascii 码表示)，节点版本。
Zookeeper进行事务日志文件操作的时候会频繁进行磁盘IO操作，事务日志的不断追加写操作会 触发底层磁盘IO为文件开辟新的磁盘块，即磁盘Seek。因此，为了提升磁盘IO的效率， Zookeeper在创建事务日志文件的时候就进行文件空间的预分配- 即在创建文件的时候，就向操 作系统申请一块大一点的磁盘块。这个预分配的磁盘大小可以通过系统参数 zookeeper.preAllocSize 进行配置。</p>
<p>事务日志文件名为: log.<当时最大事务ID>，应为日志文件时顺序写入的，所以这个最大事务 ID也将是整个事务日志文件中，最小的事务ID，日志满了即进行下一次事务日志文件的创建</p>

<h4 id="9-数据快照"><a href="#9-数据快照" class="headerlink" title="9. 数据快照"></a><span id = "1.9">9. 数据快照</span></h4><p>数据快照用于记录Zookeeper服务器上某一时刻的全量数据，并将其写入到指定的磁盘文件中。 可以通过配置snapCount配置每间隔事务请求个数，生成快照，数据存储在dataDir 指定的目录 中，<br>可以通过如下方式进行查看快照数据( 为了避免集群中所有机器在同一时间进行快照，实际的 快照生成时机为事务数达到 [snapCount/2 + 随机数(随机数范围为1 ~ snapCount/2 )] 个数 时开始快照)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp :/Users/m_yf/soft/zookeeper-3.5.9/lib/slf4j-api-1.7.25.jar:/Users/m_yf/soft/zookeeper-3.5.9/lib/zookeeper-3.5.9.jar:/Users/m_yf/soft/zookeeper-3.5.9/lib/zookeeper-jute-3.5.9.jar org.apache.zookeeper.server.SnapshotFormatter /Users/m_yf/soft/zookeeper-3.5.9/data/version-2/snapshot.0</span><br></pre></td></tr></table></figure>
<p>生成结果如下：<br><img src="https://my-life.gitee.io/mkphotorepository/202106/016.png" alt="alt "></p>
<p>快照事务日志文件名为: snapshot.<当时最大事务ID>，日志满了即进行下一次事务日志文件的 创建
有了事务日志，为啥还要快照数据。</p>
<p>快照数据主要时为了快速恢复，事务日志文件是每次事务请求都会进行追加的操作，而快照是达 到某种设定条件下的内存全量数据。所以通常快照数据是反应当时内存数据的状态。事务日志是 更全面的数据，所以恢复数据的时候，可以先恢复快照数据，再通过增量恢复事务日志中的数据 即可。</p>

<h3 id="二、Zookeeper客户端使用与集群特性"><a href="#二、Zookeeper客户端使用与集群特性" class="headerlink" title="二、Zookeeper客户端使用与集群特性"></a><span id='二、'>二、Zookeeper客户端使用与集群特性</span></h3><h4 id="1-Zookeeper-ACL权限控制"><a href="#1-Zookeeper-ACL权限控制" class="headerlink" title="1. Zookeeper ACL权限控制"></a><span id='2.1'>1. Zookeeper ACL权限控制</span></h4><p>Zookeeper 的ACL 权限控制,可以控制节点的读写操作,保证数据的安全性，Zookeeper ACL 权 限设置分为 3 部分组成，分别是:<strong>权限模式</strong>(Scheme)、<strong>授权对象</strong>(ID)、<strong>权限信息</strong> (Permission)。最终组成一条例如“scheme:id:permission”格式的 ACL 请求信息。</p>
<p>下面我们具体看一下这 3 部分代表什么意思:</p>

<h5 id="权限模式-Scheme"><a href="#权限模式-Scheme" class="headerlink" title="权限模式(Scheme)"></a>权限模式(Scheme)</h5><p>用来设置 ZooKeeper 服务器进行权限验证的方式。ZooKeeper 的权限验证方式大体分为三种 类型:</p>
<p>
一种是范围验证。所谓的范围验证就是说 ZooKeeper 可以针对一个 IP 或者一段 IP 地址授予某 种权限。比如我们可以让一个 IP 地址为“ip:192.168.0.110”的机器对服务器上的某个数据节点 具有写入的权限。或者也可以通过“ip:192.168.0.1/24”给一段 IP 地址的机器赋权。在 ZooKeeper 中这种验证方式是 IP认证。</p>
<p>
另一种权限模式就是口令验证，也可以理解为用户名密码的方式。在 ZooKeeper 中这种验证方 式是 digest 认证，而 digest 这种认证方式首先在客户端传送“username:password”这种形式 的权限表示符后，ZooKeeper 服务端会对密码 部分使用 SHA-1 和 BASE64 算法进行加密， 以保证安全性。</p>
<p>
还有一种Super权限模式(超级管理员), Super可以认为是一种特殊的 Digest 认证。具有 Super 权限的客户端可以对 ZooKeeper 上的任意数据节点进行任意操作。</p>

<h5 id="授权对象-ID"><a href="#授权对象-ID" class="headerlink" title="授权对象(ID)"></a>授权对象(ID)</h5><p>授权对象就是说我们要把权限赋予谁，而对应于不同的权限模式来说，如果我们选择采用 IP 方 式，使用的授权对象可以是一个 IP 地址或 IP 地址段;而如果使用 Digest 或 Super 方式，则 对应于一个用户名。如果是 World ，则是授权系统中所有的用户。</p>
<h5 id="权限信息-Permission"><a href="#权限信息-Permission" class="headerlink" title="权限信息(Permission)"></a>权限信息(Permission)</h5><p>权限就是指我们可以在数据节点上执行的操作种类(CRUD)，如下所示:在 ZooKeeper 中已 经定义好的权限有 5 种:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 数据节点(c: create)创建权限，授予权限的对象可以在数据节点下创建子节点;</span><br><span class="line">2. 数据节点(w: wirte)更新权限，授予权限的对象可以更新该数据节点;</span><br><span class="line">3. 数据节点(r: read)读取权限，授予权限的对象可以读取该节点的内容以及子节点的列表信</span><br><span class="line">息;</span><br><span class="line">4. 数据节点(d: delete)删除权限，授予权限的对象可以删除该数据节点的子节点;</span><br><span class="line">5. 数据节点(a: admin)管理者权限，授予权限的对象可以对该数据节点体进行 ACL 权限设置。</span><br></pre></td></tr></table></figure>
<h5 id="权限控制命令"><a href="#权限控制命令" class="headerlink" title="权限控制命令:"></a>权限控制命令:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. getAcl:获取某个节点的acl权限信息</span><br><span class="line">2. setAcl:设置某个节点的acl权限信息</span><br><span class="line">3. addauth: 输入认证授权信息，相当于注册用户信息，注册时输入明文密码，zk将以密文的形式存储</span><br><span class="line">禁用权限控制: 可以通过系统参数zookeeper.skipACL=yes进行配置，默认是no,可以配置为true, 则配置过的 ACL将不再进行权限检测</span><br></pre></td></tr></table></figure>
<h5 id="授权Id生成"><a href="#授权Id生成" class="headerlink" title="授权Id生成"></a>授权Id生成</h5><p>Zookeeper 静态类 DigestAuthenticationProvider 提供了静态方法 generateDigest 可以生成 授权ID</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sid= DigestAuthenticationProvider.generateDigest(&quot;user1:pwd1&quot;);</span><br><span class="line">sid=user1:a9l5yfb9zl8WCXjVmi5/XOC0Ep4=</span><br></pre></td></tr></table></figure>
<p>设置ACL API 有两种方式</p>
<ul>
<li>节点创建的同时设置ACL 或者 单独设置 ACL 信息</li>
<li>create [-s] [-e] [-c] path [data] [acl] 或者 setAcl /path [acl]</li>
</ul>
<p><strong>口令验证<strong></br><br>我们先用digest (口令验证)进行设置， digest 又有明文和密文两种方式，我们先用密文进行 设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /node1 data digest:user1:a9l5yfb9zl8WCXjVmi5/XOC0Ep4=:c</span><br></pre></td></tr></table></figure>
<p>上面的命令中 [user1:a9l5yfb9zl8WCXjVmi5/XOC0Ep4=] 为授权对象</br><br>如果node1 已经存在，则可以通过 setAcl 进行设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAcl /node1 digest:user1:a9l5yfb9zl8WCXjVmi5/XOC0Ep4=:c</span><br></pre></td></tr></table></figure>
<p>添加授权信息后，不能直接访问，直接访问将报如下异常</p>
<p>访问前需要添加授权信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addauth digest user1:pwd1</span><br></pre></td></tr></table></figure>
<p>另一种授权模式: auth 明文授权 使用之前需要先</br><br>addauth digest username:password 注册用户信息，后续可以直接用明文授权</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addauth digest user2:pwd2</span><br><span class="line">create /node2 node2data auth:user2:pwd2:cdwra</span><br><span class="line">这时 user2 用户授权信息会被zk保存，可以认为当前的授权用户为user2 get /node2 node2data</span><br></pre></td></tr></table></figure>
<h5 id="IP授权模式"><a href="#IP授权模式" class="headerlink" title="IP授权模式:"></a>IP授权模式:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setAcl /node-ip ip:192.168.109.128:cdwra</span><br><span class="line">create /node-ip data ip:192.168.109.128:cdwra 多个指定IP可以通过逗号分隔， 如 setAcl /node-ip ip:IP1:rw,ip:IP2:a</span><br></pre></td></tr></table></figure>
<h5 id="Super-超级管理员模式"><a href="#Super-超级管理员模式" class="headerlink" title="Super 超级管理员模式"></a>Super 超级管理员模式</h5><p>这是一种特殊的Digest模式， 在Super模式下超级管理员用户可以对Zookeeper上的节点进行任何的操作。需要通过JVM 系统参数开启:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dzookeeper.DigestAuthenticationProvider.superDigest=super1:hB2CGqPXvJ/YuuIOhzfjc0rnt+s=</span><br></pre></td></tr></table></figure>
<p>配置位置在zkServer.sh文件下<br><img src="https://my-life.gitee.io/mkphotorepository/202106/018.png" alt="alt "></p>
<h4 id="2-Zookeeper-Java客户端"><a href="#2-Zookeeper-Java客户端" class="headerlink" title="2. Zookeeper Java客户端"></a><span id='2.2'>2. Zookeeper Java客户端</span></h4><h5 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h5><p>ZooKeeper 官方的客户端没有和服务端代码分离，他们为同一个jar 文件，所以我们直接引入 ZooKeeper的maven即可， 这里版本请保持与服务端版本一致，不然会有很多兼容性的问题</br><br>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; </span><br><span class="line">     &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; </span><br><span class="line">     &lt;version&gt;3.5.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h5 id="ZooKeeper-构造函数核心参数"><a href="#ZooKeeper-构造函数核心参数" class="headerlink" title="ZooKeeper 构造函数核心参数"></a>ZooKeeper 构造函数核心参数</h5><table>
<thead>
<tr>
<th><div style="width:200px">参数名称</div></th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>connectString</td>
<td>ZooKeeper服务器列表，由英文逗号分开的 host:port字符串组成， 每一个都代表一台ZooKeeper机器，如， host1:port1,host2:port2,host3:port3。另 外，也可以在connectString中设置客户端连 接上ZooKeeper 后的根目录，方法是在host:port字符串之后 添加上这个根目录，例 如,host1:port1,host2:port2,host3:port3/zk- base,这样就指定了该客户端连接上 ZooKeeper服务器之后,所有对ZooKeeper 的操作，都会基于这个根目录。例如，客户端 对/sub-node 的操作，最终创建 /zk- node/sub-node, 这个目录也叫Chroot，即客 户端隔离命名空间。</td>
</tr>
<tr>
<td>sessionTimeout</td>
<td>会话的超时时间，是一个以“毫秒”为单位的整 型值。在ZooKeeper中有会话的概念，在一个会话周期内，ZooKeeper客户端和服务器之间会通过心跳检 测机制来维持会话的有效性，一旦在 sessionTimeout时间内没有进行有效 的心跳检测，会话就会失效。</td>
</tr>
<tr>
<td>watcher</td>
<td>ZooKeeper允许 客户端在构造方法中传入一个接口 watcher (org.apache. zookeeper. Watcher)的实现类对象来作为默认的 Watcher事件通知处理器。当然，该参 数可以设置为null 以表明不需要设置默认的 Watcher处理器。</td>
</tr>
<tr>
<td>canBeReadOnly</td>
<td>这是一个boolean类型的参数，用于标识当前 会话是否支持“read-only(只 读)”模式。默认情况下，在ZooKeeper集群 中，一个机器如果和集群中过半及 以上机器失去了网络连接，那么这个机器将不 再处理客户端请求(包括读写请 求)。但是在某些使用场景下，当ZooKeeper 服务器发生此类故障的时候，我们 还是希望ZooKeeper服务器能够提供读服务 (当然写服务肯定无法提供)——这就是 ZooKeeper的“read-only”模式。</td>
</tr>
<tr>
<td>sessionId和 ses sionPasswd</td>
<td>分别代表会话ID和会话秘钥。这两个参数能够 唯一确定一个会话，同时客户端使用这两个参 数可以实现客户端会话复用，从而达到恢复会 话的效果。具体使用方法是，第一次连接上 ZooKeeper服务器时，通过调用ZooKeeper 对象实例的以下两个接口，即可获得当前会话 的ID和秘钥:</td>
</tr>
<tr>
<td>long getSessionId(); byte[] getSessionPasswd( ); 荻取到这两个参数值之后，就可以在下次创建 ZooKeeper对象实例的时候传</td>
<td></td>
</tr>
<tr>
<td>入构造方法了</td>
<td></td>
</tr>
</tbody></table>
<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>同步创建持久化节点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zooKeeper.create(&quot;/ZK_NODE1&quot;, &quot;data&quot;.getBytes(),ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br></pre></td></tr></table></figure>
<p>异步创建节点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zooKeeper.create(&quot;/ZK_NODE2&quot;, &quot;data&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -&gt;</span><br><span class="line">    log.info(&quot;rc &#123;&#125;,path &#123;&#125;,ctx &#123;&#125;,name &#123;&#125;&quot;, rc, path, ctx, name), &quot;context&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="3-Apache-Curator-开源客户端"><a href="#3-Apache-Curator-开源客户端" class="headerlink" title="3. Apache Curator 开源客户端"></a><span id='2.3'>3. Apache Curator 开源客户端</span></h4><h5 id="什么是-Curator"><a href="#什么是-Curator" class="headerlink" title="什么是 Curator"></a>什么是 Curator</h5><p>Curator 是一套由netflix 公司开源的，Java 语言编程的 ZooKeeper 客户端框架，Curator项目 是现在ZooKeeper 客户端中使用最多，对ZooKeeper 版本支持最好的第三方客户端，并推荐使 用，Curator 把我们平时常用的很多 ZooKeeper 服务开发功能做了封装，例如 Leader 选举、 分布式计数器、分布式锁。这就减少了技术人员在使用 ZooKeeper 时的大部分底层细节开发工 作。在会话重新连接、Watch 反复注册、多种异常处理等使用场景中，用原生的 ZooKeeper 处理比较复杂。而在使用 Curator 时，由于其对这些功能都做了高度的封装，使用起来更加简 单，不但减少了开发时间，而且增强了程序的可靠性。</p>
<h5 id="Curator-实战"><a href="#Curator-实战" class="headerlink" title="Curator 实战"></a>Curator 实战</h5><p>这里我们以 Maven 工程为例，首先要引入Curator 框架相关的开发包，这里为了方便测试引入 了junit ，lombok，由于ZooKeeper本身以来了 log4j 日志框架，所以这里可以创建对应的 log4j配置文件后直接使用。 如下面的代码所示，我们通过将 Curator 相关的引用包配置到 Maven 工程的 pom 文件中，将 Curaotr 框架引用到工程项目里，在配置文件中分别引用了两 个 Curator 相关的包，第一个是 curator-framework 包，该包是对 ZooKeeper 底层 API 的一 些封装。另一个是 curator-recipes 包，该包封装了一些 ZooKeeper 服务的高级特性，如: Cache 事件监听、选举、分布式锁、分布式 Barrier。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入依赖--&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;curator-x-discovery&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.0&lt;/version&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.0&lt;/version&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.5.9&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h5 id="会话创建"><a href="#会话创建" class="headerlink" title="会话创建"></a>会话创建</h5><p>要进行客户端服务器交互，第一步就要创建会话<br>Curator 提供了多种方式创建会话，比如用静态工厂方式创建:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//重试策略</span><br><span class="line">RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3) </span><br><span class="line">CuratorFramework client = CuratorFrameworkFactory.newClient(zookeeperConnectionString, retryPolicy);</span><br><span class="line">client.start();</span><br></pre></td></tr></table></figure>
<p>或者使用 fluent ⻛格创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = new ExponentialBackoffRetry(5000, 30);</span><br><span class="line"></span><br><span class="line">curatorFramework = CuratorFrameworkFactory.builder()</span><br><span class="line">        .connectString(zkHosts)</span><br><span class="line">        .retryPolicy(retryPolicy)</span><br><span class="line">        .sessionTimeoutMs(sessionTimeoutMs)</span><br><span class="line">        .connectionTimeoutMs(connectionTimeoutMs)</span><br><span class="line">        .canBeReadOnly(true) // 集群环境</span><br><span class="line">        .build();</span><br><span class="line">curatorFramework.getConnectionStateListenable().addListener((client, newState) -&gt; &#123;</span><br><span class="line">    if (newState == ConnectionState.CONNECTED) &#123;</span><br><span class="line">        log.info(&quot;连接成功！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">log.info(&quot;连接中......&quot;);</span><br><span class="line">curatorFramework.start();</span><br></pre></td></tr></table></figure>
<p>这段代码的编码⻛格采用了流式方式，最核心的类是 CuratorFramework 类，该类的作用是定 义一个 ZooKeeper 客户端对象，并在之后的上下文中使用。在定义 CuratorFramework 对象 实例的时候，我们使用了 CuratorFrameworkFactory 工厂方法，并指定了 connectionString 服务器地址列表、retryPolicy 重试策略 、sessionTimeoutMs 会话超时时间、 connectionTimeoutMs 会话创建超时时间。下面我们分别对这几个参数进行讲解:</p>

<p>connectionString:服务器地址列表，在指定服务器地址列表的时候可以是一个地址，也可以是 多个地址。如果是多个地址，那么每个服务器地址列表用逗号分隔, 如 host1:port1,host2:port2,host3;port3 。</p>

<p>retryPolicy:重试策略，当客户端异常退出或者与服务端失去连接的时候，可以通过设置客户端 重新连接 ZooKeeper 服务端。而 Curator 提供了 一次重试、多次重试等不同种类的实现方 式。在 Curator 内部，可以通过判断服务器返回的 keeperException 的状态代码来判断是否进行重试处理，如果返回的是 OK 表示一切操作都没有问题，而 SYSTEMERROR 表示系统或服 务端错误。</p>


<table>
<thead>
<tr>
<th>策略名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ExponentialBackoffRetry</td>
<td>重试一组次数，重试之间的睡眠时间增加</td>
</tr>
<tr>
<td>RetryNTimes</td>
<td>重试最大次数</td>
</tr>
<tr>
<td>RetryOneTime</td>
<td>只重试一次</td>
</tr>
<tr>
<td>RetryUntilElapsed</td>
<td>在给定的时间结束之前重试</td>
</tr>
<tr>
<td>超时时间:Curator 客户端创建过程中，有两个超时时间的设置。一个是 sessionTimeoutMs 会话超时时间，用来设置该条会话在 ZooKeeper 服务端的失效时间。另一个是 connectionTimeoutMs 客户端创建会话的超时时间，用来限制客户端发起一个会话连接到接收 ZooKeeper 服务端应答的时间。sessionTimeoutMs 作用在服务端，而 connectionTimeoutMs 作用在客户端。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="4-Zookeeper集群特性"><a href="#4-Zookeeper集群特性" class="headerlink" title="4. Zookeeper集群特性"></a><span id='2.4'>4. Zookeeper集群特性</span></h4><h5 id="ZooKeeper-集群⻆色"><a href="#ZooKeeper-集群⻆色" class="headerlink" title="ZooKeeper 集群⻆色"></a>ZooKeeper 集群⻆色</h5><p>Zookeeper</strong> 集群模式一共有三种类型的⻆色</p>
<strong>Leader:</strong> 处理所有的事务请求(写请求)，可以处理读请求，集群中只能有一个Leader</br>
<strong>Follower:</strong> 只能处理读请求，同时作为Leader的候选节点，即如果Leader宕机，Follower节点要参与到新的Leader选举中，有可能成为新的Leader节点。 </br>
<strong>Observer:</strong> 只能处理读请求。不能参与选举</br>

<p><img src="https://my-life.gitee.io/mkphotorepository/202106/017.png" alt="alt "></p>
<h5 id="Zookeeper-集群模式安装"><a href="#Zookeeper-集群模式安装" class="headerlink" title="Zookeeper 集群模式安装"></a>Zookeeper 集群模式安装</h5><p>本次实例为伪集群搭建，真正集群模式无非在多个物理上运行实例<br>1.data目录下创建数据文件并写入myid (集群唯一标识)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cd ./data </span><br><span class="line">mkdir ./zk-1 ./zk-2 ./zk-3  ./zk-4 </span><br><span class="line">#写入myid作为集群唯一标识</span><br><span class="line">echo 1 &gt;zk1/myid</span><br><span class="line">echo 2 &gt;zk2/myid</span><br><span class="line">echo 3 &gt;zk3/myid</span><br><span class="line">echo 4 &gt;zk4/myid</span><br><span class="line"></span><br><span class="line">#设置配置文件</span><br><span class="line">cd ./conf</span><br><span class="line">cp ./zoo_sample.cfg zoo1.cfg</span><br><span class="line">#vim 修配置文件</span><br><span class="line">dataDir=/Users/m_yf/soft/zookeeper-3.5.9/data/zk1</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=127.0.0.1:2001:3001:participant // participant 可以不用写，默认就是participant server.2=127.0.0.1:2002:3002:participant</span><br><span class="line">server.3=127.0.0.1:2003:3003:participant</span><br><span class="line">server.4=127.0.0.1:2004:3004:observer</span><br></pre></td></tr></table></figure>

<p>配置说明</p>
<ul>
<li>tickTime:用于配置Zookeeper中最小时间单位的长度，很多运行时的时间间隔都是使用 tickTime的倍数来表示的。</li>
<li>initLimit:该参数用于配置Leader服务器等待Follower启动，并完成数据同步的时间。 Follower服务器再启动过程中，会与Leader建立连接并完成数据的同步，从而确定自己对 外提供服务的起始状态。Leader服务器允许Follower再initLimit 时间内完成这个工作。</li>
<li>syncLimit:Leader 与Follower心跳检测的最大延时时间</li>
<li>dataDir:顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据<br>的日志文件也保存在这个目录里。</li>
<li>clientPort:这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个<br>端口，接受客户端的访问请求。</li>
<li>server.A=B:C:D:E 其中 A 是一个数字，表示这个是第几号服务器;B 是这个服务器的<br>ip 地址;C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口;D 表示的是万 一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader， 而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端 口号。如果需要通过添加不参与集群选举以及事务请求的过半机制的 Observer节点，可以 在E的位置，添加observer标识。</li>
</ul>
<p>启动集群</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin/zkServer.sh start conf/zoo1.cfg </span><br><span class="line">bin/zkServer.sh start conf/zoo2.cfg </span><br><span class="line">bin/zkServer.sh start conf/zoo3.cfg </span><br><span class="line">bin/zkServer.sh start conf/zoo4.cfg</span><br></pre></td></tr></table></figure>
<p>检查集群状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/zkCli.sh-serverip1:port1,ip2:port2,ip3:port3,ip4:port4</span><br><span class="line">或者</span><br><span class="line">zkServer.sh status conf/zoo1.cfg</span><br></pre></td></tr></table></figure>
<h5 id="ZooKeeper-动态扩容-缩容"><a href="#ZooKeeper-动态扩容-缩容" class="headerlink" title="ZooKeeper 动态扩容/缩容"></a>ZooKeeper 动态扩容/缩容</h5><p>ZooKeeper 3.5.0 以前，ZooKeeper集群⻆色要发生改变的话，只能通过停掉所有的 ZooKeeper服务，修改集群配置，重启服务来完成，这样集群服务将有一段不可用的状态，为 了应对高可用需求，ZooKeeper 3.5.0 提供了支持动态扩容/缩容的 新特性。但是通过客户端 API可以变更服务端集群状态是件很危险的事情，所以在ZooKeeper 3.5.3 版本要用动态配置， 需要开启超级管理员身份验证模式 ACLs。如果是在一个安全的环境也可以通过配置 系统参数 -Dzookeeper.skipACL=yes 来避免配置维护acl 权限配置。</p>
<ol>
<li><p>第一步， 按照上面的演示，先配置超级管理员账户，或者 配置跳过ACL权限控制 (zookeeper.skipACL=yes)</p>
</li>
<li><p>创建文件 zoo_replicated1.cfg.dynamic 动态配置文件,加入集群信息<br>server.A=B.C.D.E;F</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A: 服务的唯一标识 </span><br><span class="line">B: 服务对应的IP地址</span><br><span class="line">C: 集群通信端口</span><br><span class="line">D: 集群选举端口</span><br><span class="line">E: ⻆色， 默认是 participant,即参与过半机制的⻆色，选举，事务请求过半提交，还有 一个是observer, 观察者，不参与选举以及过半机制。</span><br><span class="line">之后是一个分号，一定是分号</span><br><span class="line">F:服务IP:端口</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件:<br>修改配置 zoo1.cfg<br>注意这里去除了端口号，添加了<br>reconfigEnabled=true : 设置为true 开启动态配置 dynamicConfigFile=/指定路径 : 指定动态配置文件的路径</p>
</li>
</ol>
<p>zoo_replicated1.cfg.dynamic配置文件示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.1=127.0.0.1:2001:3001:participant;127.0.0.1:2181</span><br><span class="line">server.2=127.0.0.1:2002:3002:participant;127.0.0.1:2182</span><br><span class="line">server.3=127.0.0.1:2003:3003:participant;127.0.0.1:2183</span><br><span class="line">server.4=127.0.0.1:2004:3004:observer;127.0.0.1:2184</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>依次配置其他服务 zoo2.cfg ,zoo3.cfg ······ ， 注意数据文件的路径，依次启动所有服 务</li>
<li>查看集群配置信息 连上任意一台服务器:<br>执行config 命令， 查看 集群配置信息 也可以 get /zookeeper/config 进行查看</li>
<li>修改集群配置<br>如果要修改集群状态 需要先以管理员授权登录<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addauth digest super1:pwd1</span><br><span class="line"># 移除serverId为 3 的机器</span><br><span class="line">reconfig -remove 3 </span><br><span class="line"># 把对应的机器加进来</span><br><span class="line">reconfig -add server.3=127.0.0.1:2003:3003:participant;127.0.0.1:2183</span><br></pre></td></tr></table></figure>
如果要变更/或者添加新的服务需要将服务加到配置文件 zoo_replicated1.cfg.dynamic 中，启动服务,然后通过reconfig 命令进行添加或者变更服务⻆色，但是需要保证服务列表中 participant ⻆色能够形成集群(过半机制) 客户端可以通过监听 /zookeeper/confg 节点，来感知集群的变化。从而实现集群的动态变更. Zookeeper类提供了对应的API用来更新服务列表 : updateServerList</li>
</ol>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        
        <li>
            <a target="_blank" href="http://weibo.com/2561808975">
                            <span class="fa-stack fa-lg">
                                  <i class="iconfont icon-weibo"></i>
                            </span>
            </a>
        </li>
        

        

        
        <li>
            <a target="_blank"  href="https://github.com/My-Life123">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
	    <span>FRIENDLYLINk</span>
        <span>/</span>
        
        <span><a target="_blank" rel="noopener" href="https://cnsyear.gitee.io/">趙小傑~～</a></span>
        <span>/</span>
        
        <span><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012417405">10000guo</a></span>
        <span>/</span>
        
        <span><a target="_blank" rel="noopener" href="https://blog.linsans.cn">Linsans</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>  Theme <a target="_blank" rel="noopener" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
